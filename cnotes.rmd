---
title: Notes for Seamless R and C++ Integration with Rcpp
output: html_document
---

\newcommand{\bx}{\mathbf{x}}
\newcommand{\bu}{\mathbf{u}}

```{R setup, include = FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE)
```

VAR(1) $$\bx_t = A \bx_{t-1} + \bu_t$$
```{r VAR_init}
# coefficent matrix and error terms
a <- matrix(c(0.5,0.1,0.1,0.5), nrow = 2)
u <- matrix(rnorm(10000), ncol = 2)
```
```{r VAR_r}
rSim <- function(coeff, errors) {
  simdata <- matrix(0, nrow(errors), ncol(errors))
  for (row in 2:nrow(errors)) {
    simdata[row,] = coeff %*% simdata[(row-1),] + errors[row,]
  }
  return(simdata)
}

rData <- rSim(a, u) 
par(mfrow = c(1,3))
matplot(rData, type = 'l', ylab = 'x', xlim = c(4900,5000))
acf(rData[,1], main = expression(x[1]))
acf(rData[,2], main = expression(x[2]))
```

```{r VAR_c, warning = FALSE}
library(inline)
code <- '
  arma::mat coeff = Rcpp::as<arma::mat>(a);
  arma::mat errors = Rcpp::as<arma::mat>(u);
  int m = errors.n_rows;
  int n = errors.n_cols;
  arma::mat simdata(m,n);
  simdata.row(0) = arma::zeros<arma::mat>(1,n);
  for (int row = 1; row < m; row++) {
    simdata.row(row) = simdata.row(row-1)*trans(coeff) + errors.row(row);
  }
  return Rcpp::wrap(simdata);
'

# create the compiled function
rcppSim <- cxxfunction(signature(a = "numeric", u = "numeric"),
                       body = code,
                       plugin = "RcppArmadillo")
rcppData <- rcppSim(a,u) # generated by C++ code
stopifnot(all.equal(rData, rcppData)) # checking result
```

```{r VAR_cmp, warning = FALSE}
library(compiler)
compRsim <- cmpfun(rSim)
library(rbenchmark)
benchmark(rcppSim(a,u),
          rSim(a,u),
          compRsim(a,u),
          columns = c("test", "replications", "elapsed",
                      "relative", "user.self", "sys.self"),
          order="relative")
```


```{r convolution}
src <- '
  Rcpp::NumericVector xa(a);
  Rcpp::NumericVector xb(b);
  int n_xa = xa.size(), n_xb = xb.size();

  Rcpp::NumericVector xab(n_xa + n_xb - 1);
  for (int i = 0; i < n_xa; i++)
    for (int j = 0; j < n_xb; j++)
      xab[i + j] += xa[i] * xb[j];
  return xab;
'
convolution_fun <- cxxfunction(signature(a = "numeric", b = "numeric"), 
                               body = src, plugin = "Rcpp", verbose = T)
convolution_fun( 1:4, 2:5 )
```


```{r Includes}
inc <- '
  template <typename T>
  class square : public std::unary_function<T,T> {
  public:
    T operator()( T t) const { return t*t ;}
  };
'
src <- '
  double x = Rcpp::as<double>(xs);
  int i = Rcpp::as<int>(is);
  square<double> sqdbl;
  square<int> sqint;
  Rcpp::DataFrame df =
    Rcpp::DataFrame::create(Rcpp::Named("x", sqdbl(x)),
    Rcpp::Named("i", sqint(i)));
  return df;
'
fun <- cxxfunction(signature(xs = "numeric",
                             is = "integer"),
                   body = src, include = inc, 
                   plugin = "Rcpp", verbose = T)
fun(2.2, 3L)
```


```{r Plugins}
src <- '
  Rcpp::NumericVector yr(ys);
  Rcpp::NumericMatrix Xr(Xs);
  int n = Xr.nrow(), k = Xr.ncol();

  arma::mat X(Xr.begin(), n, k, false);
  arma::colvec y(yr.begin(), yr.size(), false);

  arma::colvec coef = arma::solve(X, y); // fit y ~ X
  arma::colvec res = y - X*coef; // residuals

  double s2 = std::inner_product(res.begin(),res.end(),
                                 res.begin(),double())
                                 / (n - k);
  arma::colvec se = arma::sqrt(s2 *
                    arma::diagvec(arma::inv(arma::trans(X)*X)));

  return Rcpp::List::create(Rcpp::Named("coef")= coef,
                            Rcpp::Named("se") = se,
                            Rcpp::Named("df") = n-k);
'
fun <- cxxfunction(signature(ys="numeric",
                             Xs="numeric"),
                   body = src, 
                   plugin="RcppArmadillo", verbose = T)
x <- rnorm(30)
y <- 2 + 5*x + rnorm(30)
x <- cbind(rep(1,30),x)
fun(y, x)
```


```{r Exceptions}
src <- '
  int dx = Rcpp::as<int>(x);
  if( dx > 10 )
    throw std::range_error("too big");  
  return Rcpp::wrap( dx * dx);
'
fun <- cxxfunction(signature(x = "integer"), 
                   body = src, 
                   plugin = "Rcpp", verbose = T)

fun(3)
# fun(30)
# Error in fun(30) : too big
# fun('abc')
# Error in fun("abc") : Not compatible with requested type: [type=character; target=integer].
```























