---
title: Notes for Seamless R and C++ Integration with Rcpp
output: html_document
---

\newcommand{\bx}{\mathbf{x}}
\newcommand{\bu}{\mathbf{u}}

```{R setup, include = FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE)
```

VAR(1) $$\bx_t = A \bx_{t-1} + \bu_t$$
```{r VAR_init}
# coefficent matrix and error terms
a <- matrix(c(0.5,0.1,0.1,0.5), nrow = 2)
u <- matrix(rnorm(10000), ncol = 2)
```
```{r VAR_r}
rSim <- function(coeff, errors) {
  simdata <- matrix(0, nrow(errors), ncol(errors))
  for (row in 2:nrow(errors)) {
    simdata[row,] = coeff %*% simdata[(row-1),] + errors[row,]
  }
  return(simdata)
}

rData <- rSim(a, u) 
par(mfrow = c(1,3))
matplot(rData, type = 'l', ylab = 'x', xlim = c(4900,5000))
acf(rData[,1], main = expression(x[1]))
acf(rData[,2], main = expression(x[2]))
```

```{r VAR_c, warning = FALSE}
library(inline)
code <- '
  arma::mat coeff = Rcpp::as<arma::mat>(a);
  arma::mat errors = Rcpp::as<arma::mat>(u);
  int m = errors.n_rows;
  int n = errors.n_cols;
  arma::mat simdata(m,n);
  simdata.row(0) = arma::zeros<arma::mat>(1,n);
  for (int row = 1; row < m; row++) {
    simdata.row(row) = simdata.row(row-1)*trans(coeff) + errors.row(row);
  }
  return Rcpp::wrap(simdata);
'

# create the compiled function
rcppSim <- cxxfunction(signature(a = "numeric", u = "numeric"),
                       body = code,
                       plugin = "RcppArmadillo")
rcppData <- rcppSim(a,u) # generated by C++ code
stopifnot(all.equal(rData, rcppData)) # checking result
```

```{r VAR_cmp, warning = FALSE}
library(compiler)
compRsim <- cmpfun(rSim)
library(rbenchmark)
benchmark(rcppSim(a,u),
          rSim(a,u),
          compRsim(a,u),
          columns = c("test", "replications", "elapsed",
                      "relative", "user.self", "sys.self"),
          order="relative")
```


```{r convolution}
src <- '
  Rcpp::NumericVector xa(a);
  Rcpp::NumericVector xb(b);
  int n_xa = xa.size(), n_xb = xb.size();

  Rcpp::NumericVector xab(n_xa + n_xb - 1);
  for (int i = 0; i < n_xa; i++)
    for (int j = 0; j < n_xb; j++)
      xab[i + j] += xa[i] * xb[j];
  return xab;
'
convolution_fun <- cxxfunction(signature(a = "numeric", b = "numeric"), 
                               body = src, plugin = "Rcpp", verbose = T)
convolution_fun( 1:4, 2:5 )
```

includes

```{r Includes}
inc <- '
  template <typename T>
  class square : public std::unary_function<T,T> {
  public:
    T operator()( T t) const { return t*t ;}
  };
'
src <- '
  double x = Rcpp::as<double>(xs);
  int i = Rcpp::as<int>(is);
  square<double> sqdbl;
  square<int> sqint;
  Rcpp::DataFrame df =
    Rcpp::DataFrame::create(Rcpp::Named("x", sqdbl(x)),
    Rcpp::Named("i", sqint(i)));
  return df;
'
fun <- cxxfunction(signature(xs = "numeric",
                             is = "integer"),
                   body = src, include = inc, 
                   plugin = "Rcpp", verbose = T)
fun(2.2, 3L)
```

plugin

```{r Plugins}
src <- '
  Rcpp::NumericVector yr(ys);
  Rcpp::NumericMatrix Xr(Xs);
  int n = Xr.nrow(), k = Xr.ncol();

  arma::mat X(Xr.begin(), n, k, false);
  arma::colvec y(yr.begin(), yr.size(), false);

  arma::colvec coef = arma::solve(X, y); // fit y ~ X
  arma::colvec res = y - X*coef; // residuals

  double s2 = std::inner_product(res.begin(),res.end(),
                                 res.begin(),double())
                                 / (n - k);
  arma::colvec se = arma::sqrt(s2 *
                    arma::diagvec(arma::inv(arma::trans(X)*X)));

  return Rcpp::List::create(Rcpp::Named("coef")= coef,
                            Rcpp::Named("se") = se,
                            Rcpp::Named("df") = n-k);
'
fun <- cxxfunction(signature(ys="numeric",
                             Xs="numeric"),
                   body = src, 
                   plugin="RcppArmadillo", verbose = T)
x <- rnorm(30)
y <- 2 + 5*x + rnorm(30)
x <- cbind(rep(1,30),x)
fun(y, x)
```

exception handling

```{r Exceptions}
src <- '
  int dx = Rcpp::as<int>(x);
  if( dx > 10 )
    throw std::range_error("too big");  
  return Rcpp::wrap( dx * dx);
'
fun <- cxxfunction(signature(x = "integer"), 
                   body = src, 
                   plugin = "Rcpp", verbose = T)

fun(3)
# fun(30)
# Error in fun(30) : too big
# fun('abc')
# Error in fun("abc") : Not compatible with requested type: [type=character; target=integer].
```

IntegerVector class

```{r forloopprod}
src <- '
  Rcpp::IntegerVector vec(vx);
  int prod = 1;
  for (int i=0; i<vec.size(); i++) {
    prod *= vec[i];
  }
  return Rcpp::wrap(prod);
'
fun <- cxxfunction(signature(vx = "integer"), 
                   body = src,
                   plugin = "Rcpp", verbose = T)
fun(1:10) 
```

```{r stlprod}
src <- '
  Rcpp::IntegerVector vec(vx);
  return Rcpp::wrap(std::accumulate(vec.begin(),vec.end(),
                              1, std::multiplies<int>()));
'
fun <- cxxfunction(signature(vx = "integer"),  
                   body = src,
                   plugin = "Rcpp", verbose = T)
fun(1:10)
```


NumericVector class
```{r }
src <- '
  Rcpp::NumericVector invec(vx);
  Rcpp::NumericVector outvec(vx);
  for (int i=0; i<invec.size(); i++) {
    outvec[i] = log(invec[i]);
  }
  return outvec;
'
fun <- cxxfunction(signature(vx = "numeric"),
                   body = src, plugin = "Rcpp", verbose = T)
x <- seq(1.0, 3.0, by = 1)
cbind(x, fun(x))
```

    - clone
```{r clone}
src <- '
  Rcpp::NumericVector invec(vx);
  Rcpp::NumericVector outvec = Rcpp::clone(vx);
  for (int i=0; i<invec.size(); i++) {
    outvec[i] = log(invec[i]);
  }
  return outvec;
'
fun <- cxxfunction(signature(vx = "numeric"),
                   body = src, plugin = "Rcpp", verbose = T)
x <- seq(1.0, 3.0, by = 1)
cbind(x, fun(x))
```

    - sugar
```{r sugar}
src <- '
  Rcpp::NumericVector invec(vx);
  Rcpp::NumericVector outvec = log(invec);
  return outvec;
'
fun <- cxxfunction(signature(vx = "numeric"),
                   body = src, plugin = "Rcpp", verbose = T)
x <- seq(1.0, 3.0, by = 1)
cbind(x, fun(x))
```

NumericMatrix 
```{r}
src <- '
  Rcpp::NumericMatrix mat = Rcpp::clone<Rcpp::NumericMatrix>(mx);
  std::transform(mat.begin(), mat.end(), mat.begin(), ::sqrt);
  return mat;
'
fun <- cxxfunction(signature(mx = "numeric"),
                   body = src, plugin = "Rcpp", verbose = T)
orig <- matrix(1:9, 3, 3)
fun(orig)
```

Named class
```{r}
src <- '
  Rcpp::NumericVector x = 
      Rcpp::NumericVector::create(
          Rcpp::Named("mean") = 1.23,
          Rcpp::Named("dim") = 42,
          Rcpp::Named("cnt") = 12);
  return x; 
'
fun <- cxxfunction(signature(), body = src, plugin = "Rcpp", verbose = T)
fun()
```

```{r}
src <- '
  Rcpp::NumericVector x = 
      Rcpp::NumericVector::create(
          _["mean"] = 1.23,
          _["dim"] = 42,
          _["cnt"] = 12);
  return x; 
'
fun <- cxxfunction(signature(), body = src, plugin = "Rcpp", verbose = T)
fun()
```

DataFrame class
```{r}
src <- '
    Rcpp::IntegerVector v = Rcpp::IntegerVector::create(7,8,9);
    std::vector<std::string> s(3);
    s[0] = "x";
    s[1] = "y";
    s[2] = "z";
    return Rcpp::DataFrame::create(Rcpp::Named("a")=v,
    Rcpp::Named("b")=s);
'
fun <- cxxfunction(signature(), body = src, plugin = "Rcpp", verbose = T)
fun()
```



R mathematics library 
```{r}
src <- '
    Rcpp::NumericVector x(xx);
    int n = x.size();
    Rcpp::NumericVector y1(n),y2(n),y3(n);
  
    for (int i=0; i<n; i++) {
        // accessing function via remapped R header
        y1[i] = ::Rf_pnorm5(x[i], 0.0, 1.0, 1, 0);

        // or accessing same function via Rcpps namespace R
        y2[i] = R::pnorm(x[i], 0.0, 1.0, 1, 0);
    }
    // or using Rcpp sugar which is vectorized
    y3 = Rcpp::pnorm(x);

    return Rcpp::DataFrame::create( Rcpp::Named("R") = y1,
                                    Rcpp::Named("Rf_") = y2,
                                    Rcpp::Named("sugar") = y3);
'
fun <- cxxfunction(signature(xx = "numeric"), body = src, plugin = "Rcpp", verbose = T)
fun(1:5)
```
