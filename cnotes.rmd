---
title: Notes for Seamless R and C++ Integration with Rcpp
output: html_document
---

\newcommand{\bx}{\mathbf{x}}
\newcommand{\bu}{\mathbf{u}}

```{R setup, include = FALSE}
knitr::opts_chunk$set(comment = NA, prompt = TRUE)
```

VAR(1) $$\bx_t = A \bx_{t-1} + \bu_t$$
```{r VAR_init}
# coefficent matrix and error terms
a <- matrix(c(0.5,0.1,0.1,0.5),nrow=2)
u <- matrix(rnorm(10000),ncol=2)
```
```{r VAR_r}
rSim <- function(coeff, errors) {
  simdata <- matrix(0, nrow(errors), ncol(errors))
  for (row in 2:nrow(errors)) {
    simdata[row,] = coeff %*% simdata[(row-1),] + errors[row,]
  }
  return(simdata)
}

rData <- rSim(a, u) 
par(mfrow=c(1,3))
matplot(rData, type='l', ylab = 'x', xlim = c(4900,5000))
acf(rData[,1], main = expression(x[1]))
acf(rData[,2], main = expression(x[2]))
```

```{r VAR_c, warning = FALSE}
library(inline)
code <- '
  arma::mat coeff = Rcpp::as<arma::mat>(a);
  arma::mat errors = Rcpp::as<arma::mat>(u);
  int m = errors.n_rows;
  int n = errors.n_cols;
  arma::mat simdata(m,n);
  simdata.row(0) = arma::zeros<arma::mat>(1,n);
  for (int row=1; row<m; row++) {
    simdata.row(row) = simdata.row(row-1)*trans(coeff) + errors.row(row);
  }
  return Rcpp::wrap(simdata);
'

# create the compiled function
rcppSim <- cxxfunction(signature(a = "numeric", u = "numeric"),
                       body = code,
                       plugin = "RcppArmadillo")
rcppData <- rcppSim(a,u) # generated by C++ code
stopifnot(all.equal(rData, rcppData)) # checking result
```

```{r VAR_cmp, warning = FALSE}
library(compiler)
compRsim <- cmpfun(rSim)
library(rbenchmark)
benchmark(rcppSim(a,u),
          rSim(a,u),
          compRsim(a,u),
          columns=c("test", "replications", "elapsed","relative", "user.self", "sys.self"),
          order="relative")
```